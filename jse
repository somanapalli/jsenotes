
  java-july 18th,2022
  
  
  java 
  
     -> we have two types of applications
	 
	 
	   .standalone applications/desktop apps
	   
	   .distributed applications
	   
	   
when java got released into the industry, jamesgosling released into 
three editions.

  .jse->java standard edition -> desktop applications
  .jee-> java enterprise edition -> network applications
  .jme->java micro/mobile edition -> micro related / mobile applications
  
  
 
jse:
````
 
  standalone application:
  ``````````````````````
   ->these applications which we are able to access from one machine only 
     in which machine you have installed
	 
   ->restults are not sharable across the globe.
   
   
 ex: acrobatic reader,antivirus,calculator,

 
jee:
````
  distributed applications
  
  
   ->these applicaions results are sharable across the globe.
   
   ex: 
    facebook,gmail,google..
	
	
 jee got implemented ontop of jse
why java is popular from those many years?

  java characterstics
  
  
->platform independent
->simple
->an
->portable
->dynamic
->interpreted
->secured
->robust
->distributed
-> 
  
  
jdk vs jre vs jvm:
 
  jdk stands for java development which provides following two environments
  
    1.development environment
	2.runtime environment
	

jre:
  jre stands for java runtime environment

   1.jre provides runtime environment
   

jvm:
  java virtual machine
using this -> we are able to execute the java program  
  
  
  
note:
````
every java program should starts with by defining class.

class:
`````
collection of methods + variables


variable:
``````````
 ->note: increases readability 
 
name given to memory location 

 purpose: 
  
  to store the value.
  
  
    a=100;


 <datatypename> <variablename> = <value>;
 
 int a = 100;
 byte b = 100;
 short s = 100;
 long l = 100;
 
  
  in java, we have 4 datatypes categories
  
   1.integer
     -byte(8bits)
	 -short(16bits)
	 -int
	 -long
	 
	 
   2.float
   
     -float
	 -double
	 
	 
   3.character
   
     -char
	 
   4.boolean 
     -boolean
   
   
  
  
 to calculate the formula

  -2^n-1 to (2^n-1) - 1
  
  where n -> no.of bits 
  
  

-2^7 to 2^7 -1

-128 to 127->range of byte datatype

 byte b = 127;//1 byte
 short b = 120;//2 bytes
 int b = 120;//4bytes
 
note:

by default float type data is double type 
 
float f = 23.4f;(precision -> upto 7 digits)-4 bytes
double d = 67.8; (precision -> upto 16 digits)-8 bytes

character :

 to store single character information
 
 2 bytes
 
 char c = 'r';
 
 java is following unicode character system
 
 
  ->18 international languages
  
  
boolean:
`````````
to store logical values
  true /false
  
  
  boolean b = false;
  
  true/false:
  
   because of these are the java reserved keywords
   
   java is case sensitive.
   
   note: 
   all java reserved keywords must be in lower case letters
   
   
 undefined

 

primitive datatypes:

String var = "ramakrishna";

    -variable name should always starts with character 
	-special characters are not allowed except _ and $(dollar)
	-we can't use variables names as any java reserved keywords
	-should not start with any numeric 
	-
	
java internally follows hungarian notation

  for class/interface 
  
     class TestInfo
	 {
	 }
  for variables
  
     first word first letter must be small and rest of the words first letters
	 must be in upper case.
	 
  
     String empName = "rama";
	 
	 
  for constants
  
     double PI = 3.14;
	 
  
  for methods
   
     firstword first letter must be in lower case 
	 and rest of the words first letters must be in upper case
	 ex: getStudentInfo(), getEmpSalary()....
	 
	 
  
  
 int a;
 sop(a);//0

every datatype has maintaining their own default values 
thse default values are initialized by system defined default constructor 
which will be generated by java compiler. 


note:
`````
every java program execution starts from main() 

who will call this main()?
 jvm 
 
example:
`````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);
		System.out.println(f);
		System.out.println(c);
		System.out.println(bool);
	}
}


note:
`````
can we overload the main()

yes;

exmaple:
`````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);
		System.out.println(f);
		System.out.println(c);
		System.out.println(bool);
		main();
	}
	
	public static void main()
	{
		System.out.println("iam form main");
	}
}


class

 -variables
 -methods

method:
````````
 method is the place where we are writing the logic which is used to 
 perform some operation based on the requirement.
 
 
 syntax:
   
     [accessmodifier] <returntype> <methodname>([parameters if any]) [exceptions]
	 {
	   //logic
	   
	 }
	 
	 void m1()
	 {
	 }
	 
 void is returntype it means it is not returning any value.
 
      int getAge()
	  {
	  return 55;
	  }
	  
 note:
 return type and return value must be compatible with each other 
 otherwise we will get compile time error 
 
 
 
      String getFullName(String fname,String lname)
	  {
	    return fname+lname;
	  }

note:
anything + string is always string only

example:
String toString()
{
 return empno + " " + empname + " " + empsalary;
}
	  
	  
	  
 example:
 ````````
 
   public  void  getName()
   {
     System.out.println("welcome to java sessions");
   }
   
   static int a;
   
   
   
   
 
instace vs static:
```````````````````
in java we have two areas are there

 -instance or non-static area
 
   the area which belongs to non-static method or instance method
   is known as instance area 
   
   
 -static area
 
    the area which belongs to static method is known as
	static area
	
	
 
 static properties:
 ````````````````````
 from instance area or static area we are able to access 
 static properties in following three ways.
 
         1.using classname
		 
		 2.using objectname(not recommended)
		 
		 3.direct
		 
		 
note:

for static properties memory gets created only one time.
memory gets allocated at the time of loading the class.


   String sname;
   float marks
   int id;
   static String collegeName;
   
for non staic properties memory gets created multiple times
as and when you create the object.


to whom we create the object?
 
 to class

how many we objects we can create?

 as many as you want based on the requirement.

 
example:
````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);//recommended way
		System.out.println(Test1.f);
		System.out.println(new Test1().bool);//not recommended
		
	}
	
	
}


instance properties:
`````````````````````
from instance area we are able to acess instance properties
directly

from static area we are able to access instance properties
using object name.


example:
````````

public class Test1 {
	 byte b;
	 float f;
     char c;
	 boolean bool;

	 
	 //instance method
	 
	 public void m1()
	 {
		 //instance area
		 
		 System.out.println(b);
		 System.out.println(bool);
		 System.out.println(f);
		 
	 }
	public static void main(String[] args) {
		//static area
		Test1 obj = new Test1();
		System.out.println(obj.b);
		System.out.println(obj.f);
		System.out.println(obj.bool);
		System.out.println("====================");
		//call m1()
		obj.m1();
	
	}
	
	
}


object:
``````
 ->instance of a class.
 
 instance is allocating sufficient amount of memory space for
 non static properties.
 
 
 
  ->new keyword(dynamic memory allocation operator)
  
 syntax:
 
   <classname> <objectname> = new <classname>();
   
 note:
for a single class, we can create as many as we want 

 note:
 object name is always unique.
 you can't define more than one object with same name.
 
 can we define one method inside another method?
  no
   
  
 can we call one method from another method?
  yes
 
 note:
 inner method definition is not possible where as
 inner method invocation is possible.
 
 
 example:


object initialization = object declaration + object referencing

  //object declaration
  Test obj;
  //object referencing
  obj=new Test();

variable initialization
 int x;
 x =20;
 
  Test -> class name  us user defined
  obj -> object name is user defined 
  =   -> assignment operator
  new -> dynamic memory allocation operator
  Test() -> constructor is also user defined depends on class name
  
  note: constructor name must be similar to class name.
  
  class &
  object
  
  
  java is object oriented programming language
  
     if and only if it follows oops principles
	 
	 oops principles -> are given by omg(object maangement group)
	  -candian organization
	  
	  -inheritance
	  -polymorphism
	  -encapsulation
	  -abstraction
	  
	  
conditional statements:
````````````````````````
Conditional statements define conditions that are true or false and then execute based on whether or not the condition is true

java if statement is used to test the condition 
it checks boolean condition true or false.


  -if statement
  -if else statement
  -if else if ladder
  -nested if statement


syntax

if(condition)
{
 //code to be executed
}

syntax:

 if(condition)
 {
   //code to be executed
  }
  else
  {
  //code to be executed
  }
  
 

example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=17;
		//check if the number is divisible by 2 or not
		
		if(number%2==0) {
			System.out.println("even number");
			
		}
		else
		{
			System.out.println("odd number");
		}
		
		
	
		
		
	}
	
	
}


assigment:
`````````
check if the given year is leap year or not using 
if else?


  
 ternary operator:
 `````````````````
 we can also use ternary operator(?:) to perform the task of if..else statement.
 
 it is a shorthand way to check the condition.
 
 
 if the condition is true the result of ? will be retunred
 if the condition is false the result of : will be returned.
 
 
example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=18;
		//check if the number is divisible by 2 or not
		
		String result =(number%2==0)?"even number":"odd number";
		
	  System.out.println(result);
		
		
	}

}

if-else-if ladder statement:
`````````````````````````````
it executes one condition from multiple statements.

syntax:
 if(condition1)
 {
   //code to be executed
 }
 else if(condition2)
 {
   //code to be executed if condition2 is true
 }
 else if(condition3)
 {
   //code to be executed if condition3 is true
 }
 ..
 else
 {
   //code to be executed if all conditions are false.
 }
 
assignment:
````````````
write a program of grading system based on student marks
using if-else-if ladder statement.


assignment:
write a program to check positive,negative or zero?


nested if statement:
`````````````````````
if{

  if{
  }
 }
 
example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int age=15;
		int weight=48;
		//applying condition
		if(age>=18)
		{
			if(weight>50)
			{
				System.out.println("you are eligible to donate blood");
			}
			else
			{
				System.out.println("you are not eligible to donate blood");
			}
		}
		
		else
		{
			System.out.println("age must be greater than 18");
		}
		
	}
	
	
}

switch statement:
``````````````````
switch statement executes one statement from multiple conditions.

switch statement works with byte,short,int ,long,String,enum and some 
wrapper types.

syntax:

 switch(expression)
 {
 
 case value1:
 //code to be executed;
 break;//optional
 case value2:
 //code to be executed;
 break;
 ...
 
 ...
 default:
 //code to be executed if all cases not matched
 
 }
  


assignment
````````````
finding month name for the given number?

example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		
		int number=17;
		String month="";
		//switch statement
		switch(number) {
		
		//case statements with in the switch blokc
		
		case 1: month="january";
		break;
		case 2: month="February";
		break;
		case 3: month="March";
		break;
		case 4: month="April";
		break;
		case 5: month="May";
		break;
		case 6: month="June";
		break;
		case 7: month="July";
		break;
		case 8: month="August";
		break;
		case 9: month="September";
		break;
		case 10: month="October";
		break;
		case 11: month="November";
		break;
		case 12: month="December";
		break;
		
		default: System.out.println("invalid month");
		
		
		
		}
		
		System.out.println(month);
	}
	
}

assignment:
````````````
program to check vowel or consonant?


switch case with enum type:
```````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		Day[] DayNow = Day.values();
		
		for(Day Now: DayNow)
		{
			switch(Now)
			{
			case Sun:
				System.out.println("sunday");
				break;
			case Mon:
				System.out.println("monday");
				break;	
			}
		}
		
		
	}
}


loops:
``````

if we want to execute the portion of code repeatedly based on the condition 

 in java, how many loops we have?
 
  for loop
  while loop
  do while loop
  enhanced for loop(for each loop)
  

for loop is used to iterate a part of the program several times.
if the number of iteration is fixed,it is recommended to use for loop.


inside for loop 

 we have to initialize the variable
 we have to check the condition 
 we have to increment/decrement the value.
 
 syntax:
 
  for(initialization;conditionchecking;increment/decrement)
  {
    //statement 
  }
  
example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		for(int i=1;i<=5;i++) {
		System.out.println("welcome to java session");
		}
	}
}



nested for loop:
```````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=3;i++) {
	
			//loop of j
			for(int j=1;j<=3;j++)
			{
				
				System.out.println(i + " " +j);
			}
			
			
		}
	}
}


pattern matchig example using nested for loop:
`````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=5;i++) {
	
			//loop of j
			for(int j=1;j<=i;j++)
			{
				
				System.out.print("*");
			}
			System.out.println();
			
			
		}
	}
}


while loop:
```````````
it is used to iterate a part of the program repeatedly until 
the specified condition is true
as soon as the boolean condition is false, the loop automatically stops.

if the number of iteration is not fixed, it is recommended to use
while loop.

example:
```````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}
}


display the first 10 numbers in reverse order using while loop?


public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}
}


displaying the even numbers using while loop in reverse order:
```````````````````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			if(i%2==0)
				System.out.println(i);
			i--;
		}
	}
}

do while:
`````````
 atm machines
 
 ->enter password:
 
 java do while loop is called an exit control loop
 therfore unlike while and for loop 
 the do while loop check the condition at the end of  the loop body.
 

 It is executed atleast once because condition is checked 
 after loop body.

syntax:
    do{
      //code to be executed or loop body
     }
     while(condition);


example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		do {
			System.out.println(i);
			i++;
		} while (i>=10);
	}
}



operators:
```````````
operator in java is a symbol that is used to perform 
operations

there are many types of operators in java
 
-unary operators
-arithmetic operators
-shift operator
-relational operator
-bitwise operator
-logical operator
-ternary operator
-assignment operator

  
 example on unary operator:
 
 
 
public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int x=10;
		System.out.println(x++);
		System.out.println(++x);//12
		System.out.println(x--);//12
		System.out.println(--x);//10
	}
}

example:
`````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=10;
		int b=10;
		
	System.out.println(a++ + ++a);//10+12->22
	System.out.println(b++ + b++);//10+11->21
	}
}


~ and !
 
a=10
~a ->

example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=10;
		boolean b= true;
		System.out.println(!b);//false
		System.out.println(~a);//-11
	}
}


example on bitwise operators:
``````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=12,b=10;
		/*
		 * 01100 
		 * 01010 
		 * 00110 
		 * 16 8 4 2 1
		 */
		System.out.println(a&b);//8
		System.out.println(a|b);//14
		System.out.println(a^b);//6
		
		System.out.println(a<<3);
		//formula -> 2^n * a-> 2^3 * 12 =>96
		
		System.out.println(a>>2);
		//formular -> a/2^n -> 12/4 -> 3
		
	}
}




constructor:
````````````
constructor is a special member method 
which is used to initialize the datamembers of the class.

->constructor name and class name must be similar
->constructor should not return anything even void also.
->constructor should not be inherited
->constructor should not be static.



types of constructor:

  1.default constructor
     -system defined default constructor
	 -user defined default constructor(no-arg constructor)
	 
	-it is a constructor which doesn't takes parameters
	
  2.parameterized constructor
  
    -it is  a constructor which takes parameters 
	
	
//example:


public class Test2 {
	int a;
	String b;
	boolean c;
	float f;
	
	public Test2()
	{
		a=100;
		b="rama";
		c=true;
		f=6.7f;
	}
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		
		System.out.println(obj.a + " " +obj.b + " " +obj.c + " " +obj.f);
		
		
	}

}


 example on parameterized constructor:
 ``````````````````````````````````````
 
public class Test2 {
	//class level variables
	int a;
	String b;
	
	//parameterized constructor
	public Test2(int a, String b)
	{
		this.a=a;
		this.b=b;
	}
	
	public void display()
	{
		System.out.println(this.a);
		System.out.println(this.b);
	}
	public static void main(String[] args) {
		
		Test2 obj = new Test2(100,"rama");
		obj.display();
		
		
	}

}



note:

if we define a class without having any constructors, by default java 
compiler will generate system defined default constructor and the purpose of
this constructor is to assign the default values based on the variables 
which we declared inside the class.

if we create the object using default constructor first jvm will check 
for system defined default construtor and assigns default values and then 
it will check for any user defined default constructor.

if any it found, accordingly user defined initialized values will be 
replaced with default values.

note:
````
if we define any class with parameterized constructor you can't create the
object using default constructor since java compiler will not generate 
any system defined default constructor.

in case of parameterized constructor, directly when we create the object
using parameterized constructor values will be initialized at that moment only.


this:
`````
this is a java reserved keyword which is used to always pointing to 
current class object.


->to differentiate class level variables and constructor level parameters if 
  both are same.
  
 
->to invoke current class constructor(s)


example:
````````

public class Test2 {
	
	
	//parameterized constructor
	public Test2(int a, String b)
	{
		
		System.out.println("iam parameterized constructor");
	}
	
	public Test2()
	{
		this(100,"Rama");
		System.out.println("iam default constructor");
		
	}
	
	
	public static void main(String[] args) {
		
		
		
		Test2 obj1 = new Test2();
		
		
		
	}

}

note:
`````
when we have multiple constructors to invoke all these constructors
it is not recommended to create those many objects.

just by creating only one object using any constructor we are able to 
invoke all the constructors using this()

 this() -> used for calling current class default constructor
 
 this(..) ->used for calling current class parameterized constructor
 
 
 
command line arguments:
```````````````````````
the arguments which we are passing while we are executing the java program 
are known as command line arguments.

why main() method is taking array of String as an argument?
```````````````````````````````````````````````````````````
to deal with command line arguments.


example:
`````````
public class Test3 {

	public static void main(String[] args) {
		
		System.out.println(Integer.parseInt(args[0])+Integer.parseInt(args[1]));
	}
}


note:
`````
for every data type, we have wrapper classes are there inside those wrapper 
classes we have corresponding parser methods are there for the purpose of 
converting String type data to corresponding data.


Scanner class :
```````````````
it is used to read the input from the keyboard inside Scanner class we have 
many methods which starts with next() to read different types of input data 
like nextInt() , nextBoolean(),nextFloat() etc...

example:
`````````
import java.util.Scanner;

public class Test3 {

	public static void main(String[] args) {
		
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter first number");
		
		int fno = s.nextInt();

		System.out.println("enter second number");
		
		int sno = s.nextInt();
		
		int result = fno+sno;
		System.out.println("sum of two numbers is : " + result);
		
	}
}


type casting in java:
`````````````````````
in java, type casting is a method or process that converts a datatype
into another data type in both ways manually and automatically.


The automatic conversion is done by the compiler and manual conversion 
performed by the programmer.


double -> float -> long -> int ->short ->byte

converting a value from one datat type to another data type is known 
as type casting.


there are two types of type casting:

 -widening type casting
 -narrowing type casting
 
 converting a lower data type into a higher one is called 
 widening type casting.
 
 it is also known as implicit conversion or casting down.
 
 it is done automatically.
 
 It is safe because there is no chance to lose the data.
 
 it takes place  when
  
  -both data types must be compatible with each other.
  -the target type must be larger than the source type.
  


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		int x = 5;
		
		long y = x;
		
		float z = y;
		
		System.out.println("before conversion , int value:" +x);
		System.out.println("after conversion, long value:" +y);
		System.out.println("after conversion,float value: " +z);
		
		
	}
}


narrowing type casting:
```````````````````````
converting a higher data type into a lower one is called
narrowing type casting.

it is known as explicit conversion or casting up.

it is done manually by the programmer.

double -> float -> long -> int ->short ->byte


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		double d = 323.66;
		
		//converting double data type into long data type
		
		 long l = (long)d;
		
		 //converting long data type into int data type
		 
		 int i =(int)l;
		 
		System.out.println("before conversion :" +d);
		System.out.println("after conversion, long value:" +l);
		System.out.println("after conversion,int value: " +i);
		
		
	}
}

String class api in java:
``````````````````````````
String is a predefined class available in java.lang package.

purpose: to store the series of characters.


in how many ways we can create the String object 

 -> two ways
 
 1.using String literal
 2.using new keyword
 
 String s1 = "Rama";(it gets stored inside scp memory area which is the part of 
 heap memory area which is the part of jvm which is the part of ram)
 
 
 String s2 = new String("Rama");
 (it gets stored inside heap memory area )
 
 
 note:
 `````
  scp memory area will not allow duplicates
  
  where as heap memory always creates new object irrespective
  of whether it is same or different.
  
  
 
String s1 = new String("rama");
String s2 = new String("rama");

 

String class object is immutable in nature.


unmodifiable 


->once we create any String object, on top of existing String object 
we could not perform any manipulations/modifications 

how to compare the String:
``````````````````````````
 ->by using == operator(Reference comparision operator)
 ->by using equals() or equalsIgnoreCase()
 ->by using compareTo() or compareTOIgnoreCase()
     -compareTo() compares Strings based on lexigraphical comparision.
	 -based on unicode values.
	 
	 
example:
````````
//program on string comparisions -different ways 

public class Test5 {
	
	public static void main(String[] args) {
		
		//string literal approach -it won't allow duplicates
		String s1 = "rama";
		String s2 = "rama";
		String s5 = "Rama";

		//to find out unicode value of character based on the index
		System.out.println(s1.codePointAt(0));
		System.out.println(s5.codePointAt(0));
		
		
		System.out.println(s1==s2);//true
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s5));//false
		System.out.println(s1.equalsIgnoreCase(s5));//true
		System.out.println(s1.compareTo(s2));//0
		System.out.println(s1.compareTo(s5));//32
		System.out.println(s5.compareTo(s1));//-32
		System.out.println(s1.compareToIgnoreCase(s5));//0
		
		//using new keyword -it creates everytime as a new object
		String s3 = new String("hyd");
		String s4 = new String("hyd");
		
		System.out.println(s3==s4);//false
		System.out.println(s3.equals(s4));//true
		
	}

}

 
 

  
  
  
  
  
  
  
  
  
  
  
  
  