
  java-july 18th,2022
  
  
  java 
  
     -> we have two types of applications
	 
	 
	   .standalone applications/desktop apps
	   
	   .distributed applications
	   
	   
when java got released into the industry, jamesgosling released into 
three editions.

  .jse->java standard edition -> desktop applications
  .jee-> java enterprise edition -> network applications
  .jme->java micro/mobile edition -> micro related / mobile applications
  
  
 
jse:
````
 
  standalone application:
  ``````````````````````
   ->these applications which we are able to access from one machine only 
     in which machine you have installed
	 
   ->restults are not sharable across the globe.
   
   
 ex: acrobatic reader,antivirus,calculator,

 
jee:
````
  distributed applications
  
  
   ->these applicaions results are sharable across the globe.
   
   ex: 
    facebook,gmail,google..
	
	
 jee got implemented ontop of jse
why java is popular from those many years?

  java characterstics
  
  
->platform independent
->simple
->an
->portable
->dynamic
->interpreted
->secured
->robust
->distributed
-> 
  
  
jdk vs jre vs jvm:
 
  jdk stands for java development which provides following two environments
  
    1.development environment
	2.runtime environment
	

jre:
  jre stands for java runtime environment

   1.jre provides runtime environment
   

jvm:
  java virtual machine
using this -> we are able to execute the java program  
  
  
  
note:
````
every java program should starts with by defining class.

class:
`````
collection of methods + variables


variable:
``````````
 ->note: increases readability 
 
name given to memory location 

 purpose: 
  
  to store the value.
  
  
    a=100;


 <datatypename> <variablename> = <value>;
 
 int a = 100;
 byte b = 100;
 short s = 100;
 long l = 100;
 
  
  in java, we have 4 datatypes categories
  
   1.integer
     -byte(8bits)
	 -short(16bits)
	 -int
	 -long
	 
	 
   2.float
   
     -float
	 -double
	 
	 
   3.character
   
     -char
	 
   4.boolean 
     -boolean
   
   
  
  
 to calculate the formula

  -2^n-1 to (2^n-1) - 1
  
  where n -> no.of bits 
  
  

-2^7 to 2^7 -1

-128 to 127->range of byte datatype

 byte b = 127;//1 byte
 short b = 120;//2 bytes
 int b = 120;//4bytes
 
note:

by default float type data is double type 
 
float f = 23.4f;(precision -> upto 7 digits)-4 bytes
double d = 67.8; (precision -> upto 16 digits)-8 bytes

character :

 to store single character information
 
 2 bytes
 
 char c = 'r';
 
 java is following unicode character system
 
 
  ->18 international languages
  
  
boolean:
`````````
to store logical values
  true /false
  
  
  boolean b = false;
  
  true/false:
  
   because of these are the java reserved keywords
   
   java is case sensitive.
   
   note: 
   all java reserved keywords must be in lower case letters
   
   
 undefined

 

primitive datatypes:

String var = "ramakrishna";

    -variable name should always starts with character 
	-special characters are not allowed except _ and $(dollar)
	-we can't use variables names as any java reserved keywords
	-should not start with any numeric 
	-
	
java internally follows hungarian notation

  for class/interface 
  
     class TestInfo
	 {
	 }
  for variables
  
     first word first letter must be small and rest of the words first letters
	 must be in upper case.
	 
  
     String empName = "rama";
	 
	 
  for constants
  
     double PI = 3.14;
	 
  
  for methods
   
     firstword first letter must be in lower case 
	 and rest of the words first letters must be in upper case
	 ex: getStudentInfo(), getEmpSalary()....
	 
	 
  
  
 int a;
 sop(a);//0

every datatype has maintaining their own default values 
thse default values are initialized by system defined default constructor 
which will be generated by java compiler. 


note:
`````
every java program execution starts from main() 

who will call this main()?
 jvm 
 
example:
`````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);
		System.out.println(f);
		System.out.println(c);
		System.out.println(bool);
	}
}


note:
`````
can we overload the main()

yes;

exmaple:
`````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);
		System.out.println(f);
		System.out.println(c);
		System.out.println(bool);
		main();
	}
	
	public static void main()
	{
		System.out.println("iam form main");
	}
}


class

 -variables
 -methods

method:
````````
 method is the place where we are writing the logic which is used to 
 perform some operation based on the requirement.
 
 
 syntax:
   
     [accessmodifier] <returntype> <methodname>([parameters if any]) [exceptions]
	 {
	   //logic
	   
	 }
	 
	 void m1()
	 {
	 }
	 
 void is returntype it means it is not returning any value.
 
      int getAge()
	  {
	  return 55;
	  }
	  
 note:
 return type and return value must be compatible with each other 
 otherwise we will get compile time error 
 
 
 
      String getFullName(String fname,String lname)
	  {
	    return fname+lname;
	  }

note:
anything + string is always string only

example:
String toString()
{
 return empno + " " + empname + " " + empsalary;
}
	  
	  
	  
 example:
 ````````
 
   public  void  getName()
   {
     System.out.println("welcome to java sessions");
   }
   
   static int a;
   
   
   
   
 
instace vs static:
```````````````````
in java we have two areas are there

 -instance or non-static area
 
   the area which belongs to non-static method or instance method
   is known as instance area 
   
   
 -static area
 
    the area which belongs to static method is known as
	static area
	
	
 
 static properties:
 ````````````````````
 from instance area or static area we are able to access 
 static properties in following three ways.
 
         1.using classname
		 
		 2.using objectname(not recommended)
		 
		 3.direct
		 
		 
note:

for static properties memory gets created only one time.
memory gets allocated at the time of loading the class.


   String sname;
   float marks
   int id;
   static String collegeName;
   
for non staic properties memory gets created multiple times
as and when you create the object.


to whom we create the object?
 
 to class

how many we objects we can create?

 as many as you want based on the requirement.

 
example:
````````

public class Test1 {
	static byte b;
	static float f;
	static char c;
	static boolean bool;

	public static void main(String[] args) {
		
		//static area	
		System.out.println(b);//recommended way
		System.out.println(Test1.f);
		System.out.println(new Test1().bool);//not recommended
		
	}
	
	
}


instance properties:
`````````````````````
from instance area we are able to acess instance properties
directly

from static area we are able to access instance properties
using object name.


example:
````````

public class Test1 {
	 byte b;
	 float f;
     char c;
	 boolean bool;

	 
	 //instance method
	 
	 public void m1()
	 {
		 //instance area
		 
		 System.out.println(b);
		 System.out.println(bool);
		 System.out.println(f);
		 
	 }
	public static void main(String[] args) {
		//static area
		Test1 obj = new Test1();
		System.out.println(obj.b);
		System.out.println(obj.f);
		System.out.println(obj.bool);
		System.out.println("====================");
		//call m1()
		obj.m1();
	
	}
	
	
}


object:
``````
 ->instance of a class.
 
 instance is allocating sufficient amount of memory space for
 non static properties.
 
 
 
  ->new keyword(dynamic memory allocation operator)
  
 syntax:
 
   <classname> <objectname> = new <classname>();
   
 note:
for a single class, we can create as many as we want 

 note:
 object name is always unique.
 you can't define more than one object with same name.
 
 can we define one method inside another method?
  no
   
  
 can we call one method from another method?
  yes
 
 note:
 inner method definition is not possible where as
 inner method invocation is possible.
 
 
 example:


object initialization = object declaration + object referencing

  //object declaration
  Test obj;
  //object referencing
  obj=new Test();

variable initialization
 int x;
 x =20;
 
  Test -> class name  us user defined
  obj -> object name is user defined 
  =   -> assignment operator
  new -> dynamic memory allocation operator
  Test() -> constructor is also user defined depends on class name
  
  note: constructor name must be similar to class name.
  
  class &
  object
  
  
  java is object oriented programming language
  
     if and only if it follows oops principles
	 
	 oops principles -> are given by omg(object maangement group)
	  -candian organization
	  
	  -inheritance
	  -polymorphism
	  -encapsulation
	  -abstraction
	  
	  
conditional statements:
````````````````````````
Conditional statements define conditions that are true or false and then execute based on whether or not the condition is true

java if statement is used to test the condition 
it checks boolean condition true or false.


  -if statement
  -if else statement
  -if else if ladder
  -nested if statement


syntax

if(condition)
{
 //code to be executed
}

syntax:

 if(condition)
 {
   //code to be executed
  }
  else
  {
  //code to be executed
  }
  
 

example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=17;
		//check if the number is divisible by 2 or not
		
		if(number%2==0) {
			System.out.println("even number");
			
		}
		else
		{
			System.out.println("odd number");
		}
		
		
	
		
		
	}
	
	
}


assigment:
`````````
check if the given year is leap year or not using 
if else?


  
 ternary operator:
 `````````````````
 we can also use ternary operator(?:) to perform the task of if..else statement.
 
 it is a shorthand way to check the condition.
 
 
 if the condition is true the result of ? will be retunred
 if the condition is false the result of : will be returned.
 
 
example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		int number=18;
		//check if the number is divisible by 2 or not
		
		String result =(number%2==0)?"even number":"odd number";
		
	  System.out.println(result);
		
		
	}

}

if-else-if ladder statement:
`````````````````````````````
it executes one condition from multiple statements.

syntax:
 if(condition1)
 {
   //code to be executed
 }
 else if(condition2)
 {
   //code to be executed if condition2 is true
 }
 else if(condition3)
 {
   //code to be executed if condition3 is true
 }
 ..
 else
 {
   //code to be executed if all conditions are false.
 }
 
assignment:
````````````
write a program of grading system based on student marks
using if-else-if ladder statement.


assignment:
write a program to check positive,negative or zero?


nested if statement:
`````````````````````
if{

  if{
  }
 }
 
example:
`````````

public class Test1 {
	 
	public static void main(String[] args) {
		int age=15;
		int weight=48;
		//applying condition
		if(age>=18)
		{
			if(weight>50)
			{
				System.out.println("you are eligible to donate blood");
			}
			else
			{
				System.out.println("you are not eligible to donate blood");
			}
		}
		
		else
		{
			System.out.println("age must be greater than 18");
		}
		
	}
	
	
}

switch statement:
``````````````````
switch statement executes one statement from multiple conditions.

switch statement works with byte,short,int ,long,String,enum and some 
wrapper types.

syntax:

 switch(expression)
 {
 
 case value1:
 //code to be executed;
 break;//optional
 case value2:
 //code to be executed;
 break;
 ...
 
 ...
 default:
 //code to be executed if all cases not matched
 
 }
  


assignment
````````````
finding month name for the given number?

example:
````````

public class Test1 {
	 
	public static void main(String[] args) {
		
		int number=17;
		String month="";
		//switch statement
		switch(number) {
		
		//case statements with in the switch blokc
		
		case 1: month="january";
		break;
		case 2: month="February";
		break;
		case 3: month="March";
		break;
		case 4: month="April";
		break;
		case 5: month="May";
		break;
		case 6: month="June";
		break;
		case 7: month="July";
		break;
		case 8: month="August";
		break;
		case 9: month="September";
		break;
		case 10: month="October";
		break;
		case 11: month="November";
		break;
		case 12: month="December";
		break;
		
		default: System.out.println("invalid month");
		
		
		
		}
		
		System.out.println(month);
	}
	
}

assignment:
````````````
program to check vowel or consonant?


switch case with enum type:
```````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		Day[] DayNow = Day.values();
		
		for(Day Now: DayNow)
		{
			switch(Now)
			{
			case Sun:
				System.out.println("sunday");
				break;
			case Mon:
				System.out.println("monday");
				break;	
			}
		}
		
		
	}
}


loops:
``````

if we want to execute the portion of code repeatedly based on the condition 

 in java, how many loops we have?
 
  for loop
  while loop
  do while loop
  enhanced for loop(for each loop)
  

for loop is used to iterate a part of the program several times.
if the number of iteration is fixed,it is recommended to use for loop.


inside for loop 

 we have to initialize the variable
 we have to check the condition 
 we have to increment/decrement the value.
 
 syntax:
 
  for(initialization;conditionchecking;increment/decrement)
  {
    //statement 
  }
  
example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		for(int i=1;i<=5;i++) {
		System.out.println("welcome to java session");
		}
	}
}



nested for loop:
```````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=3;i++) {
	
			//loop of j
			for(int j=1;j<=3;j++)
			{
				
				System.out.println(i + " " +j);
			}
			
			
		}
	}
}


pattern matchig example using nested for loop:
`````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		//loop of i
		for(int i=1;i<=5;i++) {
	
			//loop of j
			for(int j=1;j<=i;j++)
			{
				
				System.out.print("*");
			}
			System.out.println();
			
			
		}
	}
}


while loop:
```````````
it is used to iterate a part of the program repeatedly until 
the specified condition is true
as soon as the boolean condition is false, the loop automatically stops.

if the number of iteration is not fixed, it is recommended to use
while loop.

example:
```````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		while(i<=10)
		{
			System.out.println(i);
			i++;
		}
	}
}


display the first 10 numbers in reverse order using while loop?


public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			System.out.println(i);
			i--;
		}
	}
}


displaying the even numbers using while loop in reverse order:
```````````````````````````````````````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=10;
		while(i>=1)
		{
			if(i%2==0)
				System.out.println(i);
			i--;
		}
	}
}

do while:
`````````
 atm machines
 
 ->enter password:
 
 java do while loop is called an exit control loop
 therfore unlike while and for loop 
 the do while loop check the condition at the end of  the loop body.
 

 It is executed atleast once because condition is checked 
 after loop body.

syntax:
    do{
      //code to be executed or loop body
     }
     while(condition);


example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int i=1;
		do {
			System.out.println(i);
			i++;
		} while (i>=10);
	}
}



operators:
```````````
operator in java is a symbol that is used to perform 
operations

there are many types of operators in java
 
-unary operators
-arithmetic operators
-shift operator
-relational operator
-bitwise operator
-logical operator
-ternary operator
-assignment operator

  
 example on unary operator:
 
 
 
public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int x=10;
		System.out.println(x++);
		System.out.println(++x);//12
		System.out.println(x--);//12
		System.out.println(--x);//10
	}
}

example:
`````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=10;
		int b=10;
		
	System.out.println(a++ + ++a);//10+12->22
	System.out.println(b++ + b++);//10+11->21
	}
}


~ and !
 
a=10
~a ->

example:
````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=10;
		boolean b= true;
		System.out.println(!b);//false
		System.out.println(~a);//-11
	}
}


example on bitwise operators:
``````````````````````````````

public class Test1 {
	
	public enum Day{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
	 
	public static void main(String[] args) {
		
		int a=12,b=10;
		/*
		 * 01100 
		 * 01010 
		 * 00110 
		 * 16 8 4 2 1
		 */
		System.out.println(a&b);//8
		System.out.println(a|b);//14
		System.out.println(a^b);//6
		
		System.out.println(a<<3);
		//formula -> 2^n * a-> 2^3 * 12 =>96
		
		System.out.println(a>>2);
		//formular -> a/2^n -> 12/4 -> 3
		
	}
}




constructor:
````````````
constructor is a special member method 
which is used to initialize the datamembers of the class.

->constructor name and class name must be similar
->constructor should not return anything even void also.
->constructor should not be inherited
->constructor should not be static.



types of constructor:

  1.default constructor
     -system defined default constructor
	 -user defined default constructor(no-arg constructor)
	 
	-it is a constructor which doesn't takes parameters
	
  2.parameterized constructor
  
    -it is  a constructor which takes parameters 
	
	
//example:


public class Test2 {
	int a;
	String b;
	boolean c;
	float f;
	
	public Test2()
	{
		a=100;
		b="rama";
		c=true;
		f=6.7f;
	}
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		
		System.out.println(obj.a + " " +obj.b + " " +obj.c + " " +obj.f);
		
		
	}

}


 example on parameterized constructor:
 ``````````````````````````````````````
 
public class Test2 {
	//class level variables
	int a;
	String b;
	
	//parameterized constructor
	public Test2(int a, String b)
	{
		this.a=a;
		this.b=b;
	}
	
	public void display()
	{
		System.out.println(this.a);
		System.out.println(this.b);
	}
	public static void main(String[] args) {
		
		Test2 obj = new Test2(100,"rama");
		obj.display();
		
		
	}

}



note:

if we define a class without having any constructors, by default java 
compiler will generate system defined default constructor and the purpose of
this constructor is to assign the default values based on the variables 
which we declared inside the class.

if we create the object using default constructor first jvm will check 
for system defined default construtor and assigns default values and then 
it will check for any user defined default constructor.

if any it found, accordingly user defined initialized values will be 
replaced with default values.

note:
````
if we define any class with parameterized constructor you can't create the
object using default constructor since java compiler will not generate 
any system defined default constructor.

in case of parameterized constructor, directly when we create the object
using parameterized constructor values will be initialized at that moment only.


this:
`````
this is a java reserved keyword which is used to always pointing to 
current class object.


->to differentiate class level variables and constructor level parameters if 
  both are same.
  
 
->to invoke current class constructor(s)


example:
````````

public class Test2 {
	
	
	//parameterized constructor
	public Test2(int a, String b)
	{
		
		System.out.println("iam parameterized constructor");
	}
	
	public Test2()
	{
		this(100,"Rama");
		System.out.println("iam default constructor");
		
	}
	
	
	public static void main(String[] args) {
		
		
		
		Test2 obj1 = new Test2();
		
		
		
	}

}

note:
`````
when we have multiple constructors to invoke all these constructors
it is not recommended to create those many objects.

just by creating only one object using any constructor we are able to 
invoke all the constructors using this()

 this() -> used for calling current class default constructor
 
 this(..) ->used for calling current class parameterized constructor
 
 
 
command line arguments:
```````````````````````
the arguments which we are passing while we are executing the java program 
are known as command line arguments.

why main() method is taking array of String as an argument?
```````````````````````````````````````````````````````````
to deal with command line arguments.


example:
`````````
public class Test3 {

	public static void main(String[] args) {
		
		System.out.println(Integer.parseInt(args[0])+Integer.parseInt(args[1]));
	}
}


note:
`````
for every data type, we have wrapper classes are there inside those wrapper 
classes we have corresponding parser methods are there for the purpose of 
converting String type data to corresponding data.


Scanner class :
```````````````
it is used to read the input from the keyboard inside Scanner class we have 
many methods which starts with next() to read different types of input data 
like nextInt() , nextBoolean(),nextFloat() etc...

example:
`````````
import java.util.Scanner;

public class Test3 {

	public static void main(String[] args) {
		
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter first number");
		
		int fno = s.nextInt();

		System.out.println("enter second number");
		
		int sno = s.nextInt();
		
		int result = fno+sno;
		System.out.println("sum of two numbers is : " + result);
		
	}
}


type casting in java:
`````````````````````
in java, type casting is a method or process that converts a datatype
into another data type in both ways manually and automatically.


The automatic conversion is done by the compiler and manual conversion 
performed by the programmer.


double -> float -> long -> int ->short ->byte

converting a value from one datat type to another data type is known 
as type casting.


there are two types of type casting:

 -widening type casting
 -narrowing type casting
 
 converting a lower data type into a higher one is called 
 widening type casting.
 
 it is also known as implicit conversion or casting down.
 
 it is done automatically.
 
 It is safe because there is no chance to lose the data.
 
 it takes place  when
  
  -both data types must be compatible with each other.
  -the target type must be larger than the source type.
  


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		int x = 5;
		
		long y = x;
		
		float z = y;
		
		System.out.println("before conversion , int value:" +x);
		System.out.println("after conversion, long value:" +y);
		System.out.println("after conversion,float value: " +z);
		
		
	}
}


narrowing type casting:
```````````````````````
converting a higher data type into a lower one is called
narrowing type casting.

it is known as explicit conversion or casting up.

it is done manually by the programmer.

double -> float -> long -> int ->short ->byte


example:
`````````

public class Test4 {

	
	public static void main(String[] args) {
		
		double d = 323.66;
		
		//converting double data type into long data type
		
		 long l = (long)d;
		
		 //converting long data type into int data type
		 
		 int i =(int)l;
		 
		System.out.println("before conversion :" +d);
		System.out.println("after conversion, long value:" +l);
		System.out.println("after conversion,int value: " +i);
		
		
	}
}

String class api in java:
``````````````````````````
String is a predefined class available in java.lang package.

purpose: to store the series of characters.


in how many ways we can create the String object 

 -> two ways
 
 1.using String literal
 2.using new keyword
 
 String s1 = "Rama";(it gets stored inside scp memory area which is the part of 
 heap memory area which is the part of jvm which is the part of ram)
 
 
 String s2 = new String("Rama");
 (it gets stored inside heap memory area )
 
 
 note:
 `````
  scp memory area will not allow duplicates
  
  where as heap memory always creates new object irrespective
  of whether it is same or different.
  
  
 
String s1 = new String("rama");
String s2 = new String("rama");

 

String class object is immutable in nature.


unmodifiable 


->once we create any String object, on top of existing String object 
we could not perform any manipulations/modifications 

how to compare the String:
``````````````````````````
 ->by using == operator(Reference comparision operator)
 ->by using equals() or equalsIgnoreCase()
 ->by using compareTo() or compareTOIgnoreCase()
     -compareTo() compares Strings based on lexigraphical comparision.
	 -based on unicode values.
	 
	 
example:
````````
//program on string comparisions -different ways 

public class Test5 {
	
	public static void main(String[] args) {
		
		//string literal approach -it won't allow duplicates
		String s1 = "rama";
		String s2 = "rama";
		String s5 = "Rama";

		//to find out unicode value of character based on the index
		System.out.println(s1.codePointAt(0));
		System.out.println(s5.codePointAt(0));
		
		
		System.out.println(s1==s2);//true
		System.out.println(s1.equals(s2));//true
		System.out.println(s1.equals(s5));//false
		System.out.println(s1.equalsIgnoreCase(s5));//true
		System.out.println(s1.compareTo(s2));//0
		System.out.println(s1.compareTo(s5));//32
		System.out.println(s5.compareTo(s1));//-32
		System.out.println(s1.compareToIgnoreCase(s5));//0
		
		//using new keyword -it creates everytime as a new object
		String s3 = new String("hyd");
		String s4 = new String("hyd");
		
		System.out.println(s3==s4);//false
		System.out.println(s3.equals(s4));//true
		
	}

}

 
checking immutability vs mutablity using String,StringBuffer and StringBuilder:


public class Test6 {

	public static void main(String[] args) {
		
		//immutable object
	 String s1 = "Rama";
	 s1.concat("hyd");
	 System.out.println(s1);//Rama
	   //mutable object
	 StringBuffer s2 = new StringBuffer("Rama");
	 s2.append("hyd");
	 System.out.println(s2);//Ramahyd
	  //mutable object
	 StringBuilder s3 = new StringBuilder("Rama");
	 s3.append("hyd");
	 System.out.println(s3);//Ramahyd
	 
	 
	 
	}
}


note:
using StringBuffer & StringBuilder we can create mutable Strings but 
differnce is StringBuffer methods are synchrnozed(thread safe) methods where as
StringBuilder methods are non-synchrnized(not thread safe) methods.

example on frequently used methods of String class:
````````````````````````````````````````````````````

public class Test6 {

	public static void main(String[] args) {
		
		String s1 = new String("Rama");
		String s3= new String("Rama");
		String s4 = new String("Rama,hyd,software,hardware");	
		String s2 = "  banga  lore   ";
		int value=40;
		String s5 = String.valueOf(value);
		
		String str = new String("welcome to java sessions");
	
		System.out.println("length of the stirng: " + s1.length());
		
		System.out.println("character at 0th position: " + s1.charAt(0));//R
		
		System.out.println(s1.concat("hyd"));//Ramahyd
		
		System.out.println(s1.contains("R"));//true
		System.out.println(s1.contains("j"));//false
		
		System.out.println(s1.endsWith("j"));
		System.out.println(s2.indent(2));//  banga  lore
		System.out.println(s2.indent(-2));//banga  lore
		System.out.println(s2.indent(0));//  banga  lore	
		System.out.println(s1.intern()==s3.intern());//true
		System.out.println(s1.substring(1));//ama
		System.out.println(s1.substring(0, 3));//Ram
		String[] split = s4.split(",");
		for(String s:split)
		{
			System.out.println(s);
		}
		
		System.out.println(s5+10);
		System.out.println(s2.length());
        System.out.println(s2.strip().length());
        
        System.out.println(str.matches("welcome(.*)"));
        System.out.println(str.matches("tutorials"));
 
	}
}


java Arrays:
````````````


syntaxes:

 datatype[] arr;
 datatype []arr;
 datatype arr[];
 
instantiation of an array:
<arrayreferencevariable> = new datatype[size];


example:
`````````

public class Test7 {

	public static void main(String[] args) {
		
		//declaration cum instantiation
		int a[] = new int[3];
		//initialization
		a[0]=100;
		a[1]=200;
		a[2]=300;
		
		//int a[]= {100,200,300};
		//traversing an array using for loop
		
		for(int i=0;i<a.length;i++)
		{
			System.out.println(a[i]);
		}
		System.out.println("=============");
		
		//traversing an array using for each loop
		
		for(int b:a)
		{
			System.out.println(b);
		}
	}
}


example on anonymous array:
````````````````````````````

public class Test7 {

	static void printArray(int arr[])
	{
		for(int i=0;i<arr.length;i++)
			System.out.println(arr[i]);
	}
	public static void main(String[] args) {
		
		printArray(new int[]{100,200,300});
		
	}
}

example on returning array from a method:
``````````````````````````````````````````

public class Test7 {

	static int[] get()
	{
		return new int[]{100,200,300};
	}
	public static void main(String[] args) {
		
		int arr[]=get();
		//print the array data
		
		for(int a:arr)
		{
			System.out.println(a);
		}
	}
}



multidimensional array:
```````````````````````
datatype referncevariable[][];

int[][] arr = new int[3][3];

example:
`````````


public class Test7 {

	public static void main(String[] args) {
		
		int arr[][]= {{1,2,3},{4,5,6},{7,8,9}};
		int x[]= {1,2,3};
		for(int i=0;i<3;i++) {
			for(int j=0;j<3;j++)
			{
				System.out.print(arr[i][j] + " ");
				 
			}
			System.out.println();
			
			System.out.println(arr.getClass().getName());
		    System.out.println(x.getClass().getName());
		}
	}
}


//assigment:
write a program for cloning an array?

write a program for addition of two matrices?









java is object oriented programming language

 -> since it follows omg derived principles
 
 inheritance
 polymorphism
 abstraction
 encapsulation
 
class & object


inheritance:
`````````````
  it is the process of taking the properties from one class to another 
  class.
  
  the class which is giving the properties is known as base/super/parent 
  class.
  
  the class which is taking the properties is known as sub/derived/child
  class.
  
  note:
  `````
  using extends keyword we can achieve the concept of inheritance.
  in the context of child class only we have to use extends keyword.
  
  types of inheritances:
  
   simple/single inheritance
   multilevel inheritance
    multiple inheritance
   hierarchical inheritance
   hybrid inheritance
   
   
   E
   
   D
  
  A B C
  
   
  
 note:

 using extends keyword we are able to derive single class from single class 
not from multiple classes or more than one class.

 
->reusability


note:
````
if we create the child class object, memory locations will be created for 
both parent class properties and child class properties where as 
if we create the object for parent class object, only we are able to access
parent class properties.


is-a relation 
``````````````
whenever one class inherits another class,it is called as 
an IS-A relationship.

HAS-A relation:
`````````````````
wheneve an instance of one class is used in another class, it is called
HAS-A relationship.


Parent.java:
````````````
//parent class cum busines logic class
public class Parent {
	
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}

}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	public void sub(int x, int y)
	
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test7.java(execution logic class):
````````````````````````````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		
		Child obj = new Child();
		obj.sum(2, 3);
		obj.sub(4, 3);
		
	}
}

  
 note: constructor should not be inherited.

 
super:
``````
super is a java reserved keyword.
it is always refering immediate parent class properties.

  
  super at variable level
  super at method level
  super at constructor level.
  
  
example:
````````
//parent class cum busines logic class
public class Parent {
	
	int x=100;
	
	
	
}

Child.java:
````````````
//child class cum business logic class
public class Child extends Parent {
	
	int x=200;

	public Child()
	{
		System.out.println(x);
		System.out.println(super.x);
	}

}

Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}
 
  
note:
`````
writing the super() is optional for to invoke the parent class default 
constructor

note:

writing the super(..) is mandatory to invoke parent class parameterized 
constructor when there is no default constructor.


Parent.java:
````````````
//parent class cum business logic class
public class Parent {

	public Parent(int x, int y)
	{
		System.out.println("iam from parameterized constructor-parent");
	}

	
	
}

Child.java:
```````````
//child class cum business logic class
public class Child extends Parent {

	
	public Child() {
		//invoke parent class parameterized constructor
		super(2,3);
		System.out.println("iam from default constructor-child class");
		
	}

}


Test7.java:
```````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		
		//create the object for child class
		Child obj = new Child();
		
	}
}

  
note:
`````
for every constructor super()is added automaticlly by the java compiler which 
internally invokes parent class default constructor.

 
assignment: write a program which describes super at method level.



note:
`````
multiple inheritance is not possible through the concept of classe(s) , because 
of we will get ambiguity issue if two parent classes are maintaining same 
properties.

this problem we can achieve by using interface concept.


 class Object{
 }

 class A extends Object
 {
 }
 class B extends A
 {
 }
 class C extends B
 {
 }

note:
````
every java class is an example of inheritance or
every java class is a sub class or child class.

because for every java class whether it is predefined or user defined 
Object class is acting as a parent class.


assignment:
`````````````
write one program on Object class methods(11 methods)



note:
````
difference between this() and super()?

 this()or this(..) 
  
   ->refering current class default or parameterized constructor(s)
  
 super() or super(..)
 
   ->refering parent class default or parameterized constructor(s)
   
 super.<variablename>
   ->refering parent class variable 
   
 super.methodname()
  
   ->refering parent class method.
   
   
polymorphism:
``````````````
it is the process of defining one action into many forms.

  types of polymorphism
  
   
   -compile time polymorphism
   
     -this polymorphism can be decided at compiletime by the java compiler
	 -when we call the method , method call is binded to which method will 
	  be decided at compiletime by the java compiler.
	  
	  
   -runtime polymorphism
   
   
in java, how we can achieve this polymorphism?

  we have two concepts 
  
   1.method overloading
   2.method overriding
   
   
method overloading:
 
   method name is same
   but signature is different
   
    -type of parametrs
	-no.of parameters
	-atleast order of parameters
	
	
advantages of method overloading:
`````````````````````````````````
1.it improves the readability of written code
2.it adds cleanliness to the code written
3.it can be used on constructors also so that we can 
  create different objects by passing different data.
  
  
  note:
  to achieve method overloading , one class is more than enough.
  
  
note:
by changing returntype can we perform method overloading?

no, only by changing signature.


example:
````````
//example for method overloading cum compiletime polymorphism
public class Test8 {
	
	public void sum(int x, int y)
	{
		System.out.println("Integer sum: " + (x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum: " + (x+y));
	}

	public static void main(String[] args) {
		//objcet declaration at compiletime
		Test8 obj;
	    //object creation at runtime	
		obj=new Test8();
		
		obj.sum(2, 3);
		obj.sum(4.5,4.5);
		
	}
}

note:
`````
we can achieve the method overloading using object reference 
variable. 


method overriding:
``````````````````
-method name is same
-but logic is different from parent class to child class.

note:
to achieve method overriding minimum we require 
two classe(s) with parent-child realtion.


why should we go for method overriding?
```````````````````````````````````````
we have already parent class method has some logic
if we don't require or if we want to provide some new logic 
then we can go for method overriding.

Object 
  -toString()
  -className@HashCode
  
  
rules for method overriding:

 1.method must have the same name as in the parent class.
 2.method must have the same parameter as in the parent class.
 3.there must be an is-a realtionship.
 4.@Override annotation is recommended while we are overriding.
 
 
Parent.java:
````````````

public class Parent {

	public void sum()
	{
		System.out.println("sum-parent");
	}
	
}

Child.java:
````````````
public class Child extends Parent {

	@Override
	public void sum()
	{
		System.out.println("sum-child");
		//call the super class method
		super.sum();
	}
}

Test7.java:
````````````
//execution logic class
public class Test7 {

	public static void main(String[] args) {
		//Child obj = new Child();
		//Parent obj = new Parent();
		Parent obj=new Child();
		//Child obj =new Parent();
		obj.sum();
		
	}
}


note:
`````
based on the object type which method will be associated with 
which method that will be decided is called as 
runtime polymorphism.

based on the object reference varaible it is not possible.


static methods are not participating in method overriding.


note:
`````
while we are overriding we are allowed to increase the scope of the 
property not possible to decrease the scope of the property.

  private -> default -> protected ->public 

  
private properties are not eligible for method overriding, since private
properties only we are able to access within the class not from outside 
the classe(s).


final methods/properties are not eligile for method overriding, since 
final properties are constants ,  modifications are not possible.


abstraction:
````````````
  -security
  -enhancements
  -manitability
  -modularity
  
  
  hiding the implementation details and showing only services to the end users.
  
abstraction is also one of the oop principle.

   -abstract classe(s)(partial abstraction)
   -interface
   

abstract class:
````````````````
 ->concrete classes (fully defined classes)
 ->abstract class 
 
 abstract class is a combination of both 
 defined methods 
 and as well as undefined methods
 
 undefined method/abstract method:
   
     public abstract void getRateOfInterest();->method declaration
	 
	 
	 
note:

  if a class contains atleast one abstract method it is highly 
recommended to make corresponding class also as 
abstract class using abstract keyword before the class declaration.



    abstract class Test{
    public abstract void m1();
	public void m2(){}
	
	public Test()
	{
	}
	}

  
 for a single abstract class, how many implementation classe(s) we can define?
 
 as many as you want.

 
  class Test1 extends Test
  {
    public void m1(){}
	
	public Test1()
	{
	  super();
	}
  }


  Test obj = new Test1();
  
  obj.m1();
 

in abstract class, can we define constructor(s)?
yes

Bank.java:
```````````


abstract public class Bank {

	 abstract int getRateOfInterest();
}

SBI.java:
``````````

public class SBI extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 5;
	}

}

CityBank.java:
```````````````

public class CityBank extends Bank {

	@Override
	int getRateOfInterest() {
		// TODO Auto-generated method stub
		return 7;
	}

}



TestBank.java:
``````````````

public class TestBank {
public static void main(String[] args) {
	
	Bank b ;
	b=new SBI();
	System.out.println("sbi bank rate of interest is : " + b.getRateOfInterest());
	
	b =new CityBank();
	System.out.println("city bank rate of interest is : " + b.getRateOfInterest());
}
}


example on abstract class with constructor:
````````````````````````````````````````````

abstract public class Bike {
	
	Bike()
	{
		System.out.println("bike is created");
	}

	void changeGear()
	{
		System.out.println("gear changed");
	}
	
	abstract void run();
}


Honda.java:
````````````

public class Honda extends Bike {

	@Override
	void run() {
		
		System.out.println("running safely...");

	}

}

TestAbstraction.java:
`````````````````````
public class TestAbstraction {
public static void main(String[] args) {
	
	
	Bike obj = new Honda();
	obj.run();
	obj.changeGear();
}
}


interface:
``````````

interface
implemetnatin class
execution logic class



interface i1
{
  public abstract void m1();
  public static final int x=100;
}

note:
by default interface methods are public abstract 
and by default interface datamembers are public static final.


 extends: 
 
 using extends keyword we can take the properties from 
 class to class and interface to interface (homogenious)
 
 implements:
 
 using implements keyword we can take the properties from 
 interface to class(heterogenious)
 
 assignment:
 do one program on top of interface
 
interface inheritance and multiple inheritance:
```````````````````````````````````````````````

public interface i1 {
	
	void m1();

}


i2.java:
`````````

public interface i2 extends i1 {
void m2();
}


Test9.java:
```````````

public class Test9 implements i2 {

	@Override
	public void m2() {
		System.out.println("m2 body");

	}

	@Override
	public void m1() {
		System.out.println("m1 body");

	}
	
	public static void main(String[] args) {
     	i2 obj;
		obj = new Test9();
		obj.m1();
		obj.m2();
	
	}

}






encapsulation:
``````````````

encapsulation = datahiding + abstraction

encapsulated class:

 class is the best example for an encapsulation.
 
 by declaring datamembers as private 
 and by defnining public setters and getter methods(s).
 
 
Student.java:
``````````````

public class Student {

	//data hiding
	private int stid;
	private String stname;
	
	//abstraction 
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	
}
Test10.java:
````````````

public class Test10 {
	
	public static void main(String[] args) {
		Student student = new Student();
		
		student.setStid(100);
		student.setStname("Rama");
		
		System.out.println("student id: " + student.getStid());
		System.out.println("student name: " + student.getStname());
		
	}

}


packages:
``````````
package is a 
   collection of 
    
	   classes,interfaces & sub packages
	   
	   classes
	   interfaces
	   annotations
	   exceptions
	   errors
	   enums
	   
	   

types of packages:
  1.pre-defined packages->sunmicrosystems
  
   ->to perform common operations
   
   jse,jee,jme-
   
   note: all jse packages starts with java.
 
list of predefined jse packages:
`````````````````````````````````
java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io
java.lang
java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip
 
   
  2.user-defined packages
  
  
advantage:
```````````
->reusability
->avoid naming conflicts

System.out.println();

PrintStream class 

  println()
  print()

out object is available as a static data member inside
System class. 

System.out.print();


note:
by default java.lang package will be imported to 
each and every java program.


except java.lang package releated api,if we really need any other packages 
api's , for sure we have to import those packages into our program. 
otherwise we will get compiletime error.

syntax:

          import <packagename>.<classname>/<interfacename>;
		  import <packagename>.*;
		  
		  

user-defined packages:
````````````````````````
  we can define our own package just to keep our own clases or our 
  own interfaces..
  
  syntax:
  
      package <packagename>;
	  
      class {}
	  
	  interface {}
	  
note:
package statement always must be the first executable statement.

note:
if we didn't keep our classes/interfaces inside a package, by default jvm 
will keep those inside default package

default package name given by sunmicrosystem -> noname


note:

if two classes are belongs to same package, from one class if we want to 
access other class methods 'import' is not required.

Test1.java:
```````````
package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test2.java:
```````````
package p1;
//execution logic class
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 3);
		
	}

}

naming convention to create package(s):
``````````````````````````````````````
   <reversedomainofcompanyurl>.<projectname>.<modulename>;
   
   com.wipro.banking.fundtransfer;
   
   com.wipro
     com.wipro.banking
	 com.wipro.fundtransfer
   
Test1.java:
`````````````
package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test3.java:
```````````
package p2;
import p1.Test1;
public class Test3 {
	
	
	public static void main(String[] args) {
		
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
		
	}

}


note:
`````
by importing main package,we won't get sub packages properties
if we want subpackages properties we need to import subpackage too explicitly.


package p1;
//business logic class
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println(x+y);
	}

}


Test2.java:
```````````
package p1.p2;

public class Test2 {
	public void sub(int x, int y)
	{
		System.out.println("substraction is: " + (x-y));
	}

}


Test3.java:
````````````
package p3;
import p1.Test1;
import p1.p2.Test2;
//execution logic class
public class Test3 {

	public static void main(String[] args) {
		
		Test1 obj1  = new Test1();
		Test2 obj2 = new Test2();
		
		obj1.sum(3, 4);
		obj2.sub(4,3);
		
	}
	
}



accesmodifiers:
````````````````

it is used to control the scope of the visibility over the package(s).


  private 
  default(not a keyword)
  protected
  public
  
  
 private properties we can access only with in class 
 not able to access 
  same package subclass/non-subclass
  other package subclass/non-subclass

 default properties we can access 
  with in the class
  same pacakge subclass/subclass but not from 
  other package subclass/non-subclass

 protected properties we can access 
  with in the class 
  same pacakge subclass/non-subclass
  other package sub class but not from 
  other package non-subclass
 
when it comes to public from any where we can access there is no 
restriction.

 
 exception handling :
 ``````````````````
 
 erros are of two types
   
    ->compiletime errors->poor in syntaxes
	->runtime errors-> when we pass invalid input
	
	            ->100/20 ->5
				->100/0 ->java.lang.ArithmeticException: /by zero 
 
   exceptions
   
   
 drawbacks of exceptions:
 ````````````````````````
 ->control terminates abnormally
 
 --
 -- int x = 100/0;
 --
 1000
 
 ->we are not able to maintain normal flow of execution 
 ->if exception occurs , we will get system error messages
   which are not understable by end user which is not 
   recommende.
   
   
 we have to handle the exception
 
  how can we handle the exceptions?
  
     ->try
	 ->catch
	 ->finally
	 ->throws
	 ->throw
	 
	 
 types of exceptions:
 
   ->pre-defined exceptions
   ->user-defined exceptions
   
 

java.lang.Object
 
      Throwable

Error       Exception 


 ->pre-defined exceptions
  
     ->asynchronous exceptions ->if any hardware related issues
	 
	   java.lang.OutOfMemoryException,stackOverFlow ...
	   
	 ->synchronous exceptions->if any programatical errors
	 
	            ->checked exceptions->ex: SQLException,IOException,...
				->unchecked exceptions-> RuntimeException
				
 
 
   hallticket -> HallTicketNotFoundException
   
   pen -> PenNotFoundException
   
   BombBlastException
   
 
 -predefined exceptions for to handle universal problems.
 
 
   jvm internally throws a particular/specific exception
   
   
 
 without handling the exception:
 ``````````````````````````````
 package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
		
		System.out.println("division is: " + z);
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
	}

}


try:
````
try block is used to keep 

 ->problematic statements which causes problems at runtime.
 
 syntax:
   
     try
	 {
	   //problematic statements
	 }
 

catch block:
`````````````
 ->to catch the exception
 
 syntax:
 
   catch(<exceptionclassname> <referencevariablename>)
   {
    //user friendly message
   }
   
note:
while we are handling the exceptions, we should always follows the order
which is from  specific to general otherwise we will get compile time error
saying that unreachable code for the java compiler.

example:
`````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		    int x= Integer.parseInt(args[0]);
		    int y = Integer.parseInt(args[1]);		
	     	int z = x/y;
	     	System.out.println("division is: " + z);
		}
		
		
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as a denominator");
		}
		
		catch(NumberFormatException nfe)
		{
			System.out.println("please pass only numerics");
		}
		
		catch(ArrayIndexOutOfBoundsException ai)
		{
			System.out.println("please supply the input");
		}
	
		catch(RuntimeException re)
		{
			System.out.println(re);
			
		}
		
		
		
		System.out.println("Rest of the statements  executed");
		System.out.println("Rest of the statements not executed");
		System.out.println("Rest of the statements not executed");
		
		
		
	}

}


nested try block:
`````````````````
package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			
			try {
				System.out.println("divide by 0");
				int x = 40/0;
			}
			catch(ArithmeticException ae)
			{
				System.out.println(ae);
			}
			
			try {
				int x[] = new int[5];
				x[5]=4;	
			}
			
			catch(ArrayIndexOutOfBoundsException ai)
			{
				System.out.println(ai);
			}
			
			System.out.println("other statements");
		}
		//catch block of outer try block
		
		catch(Exception e)
		{
			System.out.println("handled the exceptions");
		}
		
		System.out.println("Normal flow");
		
	}

}


finally block:
``````````````

package com.citus.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}
		
		
		finally
		{
			System.out.println("Finally block executed");
		}
		System.out.println("Normal flow");
		
	}

}

finally block always executed whether exception occurs or not?
note:
we are writing the finally block is for keeping closing related logic
or to close the resources.

 like conneciton closeing logic, closing the file objects etc.. to escape
 from memory leakage problem or data leakage problem(s).
 
 
->try with finally block is possible
->exclusive only finally block is not possible.
->try ,catch and finally blcoks is possible
->in between try and catch is it possible to write finally block ->no
->nested try block with finally also possible.

 

   


throws:
```````

throws keyword gives an indication to the calling fucntion to keep 
called function under try and catch block.



//called
class Test{
 void div() throws ArithmeticException
 {//ae}
 }

//calling 
class Demo{
  Test ob = new Test();
  try{
  obj.div();
  }
  catch(AE ae){
  }
}


parseInt()

sleep() throws InterruptedException 

Test1.java:
```````````
package com.citus.exceptions;
//called program
public class Test1 {
	
	public void div() throws ArithmeticException
	{
		int x=100/0;
		
	}

}


Test2.java:
```````````
package com.citus.exceptions;
//calling program
public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		try {
		obj.div();
		}
		catch(ArithmeticException ae)
		{
			System.out.println(ae);
		}
		System.out.println("Rest of the statements");
		
	}

}

throw:
``````
throw is a java reserved keyword which is used to throw an exception explictly.

 int x = 100/0;
 
    ArithmeticException ae = new ArithmeticException();
	

note:
we are using this throw keyword to throw a user defined exception explictly 
not for pre-defined execption.


syntax:

   throw new <exceptionclassname>();
   
note:
every exception internally it is a class.


example:
````````
package com.citus.exceptions;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		String str = "rama";
		if(str.startsWith("r"))
		{
			try {
			throw new ArithmeticException();
			}
			catch(ArithmeticException ae)
			{
				System.out.println("String is invalid");
			}
		}
		else
		{
			System.out.println("String is valid");
		}
		
		
	}

}


user defined exceptions using throw keyword:
``````````````````````````````````````````````
package com.citus.exceptions;

public class Test3 {
	
	public void checkProduct(int weight) {
		if(weight>=100)
		{
			System.out.println("product is valid");
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ipe)
			{
				System.out.println("product weight must be greater than 100kgs");
			}
		}
		
	}
	public static void main(String[] args) {
		
		Test3 obj = new Test3();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
class InvalidProductException extends Exception 
{
}

note:
`````
to make normal java class as an exception class, make sure that class must be
extending from Exception class.


exception handling with method overriding:
```````````````````````````````````````````
.if the superclass method doesnot declare an exception,sub class overriden 
 method cannot declare the checked exception but it can declare unchecked
 exception.
 
.if the superclass method declares an exception, sub class overriden method 
can declare same,subclass exception or no exception but cannot declare 
parent exception.
     sum() throws RuntimeException{}
	 
	 sum()throws Exception{}

example for exception propagation:
``````````````````````````````````
package com.citus.exceptions;


public class Test4 {
	
	void m()
	{
		int x=7/0;
	}
	void n()
	{
		m();
	}
	void p()
	{
		try {
		n();
		}
		catch(Exception e)
		{
			System.out.println("exception handled");
		}
	}
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.p();
		System.out.println("normal flow");
	}

}

note:
````
an exception is first thrown from the top of the stack and if it is not caught,
it drops down to the call stack to the previous method.
if not caught there,the exception again drops down to the call stack to the 
previous method , and so on until they are caught or until they reach 
the very bottom of the call stack 

This is called exception propagation.

















 
  